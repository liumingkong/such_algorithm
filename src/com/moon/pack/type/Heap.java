package com.moon.pack.type;

/**
 * @ClassName: Heap 
 * @Description: 堆
 * @author liuzhao
 * @date 2013-6-3 下午10:35:10 
 * 
 * <br>二叉堆
 * <br>在二叉堆的数组中，每个元素都要保证大于等于另两个特定位置的元素
 * <br>相应地，这些位置的元素又至少大于等于数组中的另两个元素
 * <br>
 * <br>定义：当一棵二叉树的每个结点都大于等于它的两个子节点时，它被称为堆有序
 * <br>推理：在堆有序的二叉树中，每个结点都小于等于它的父结点（如果有的话），
 * 从任意结点向上，我们都能得到一列非递减的元素；
 * 从任意结点向下，我们都能得到一列非递增的元素；
 * <br>
 * <br>命题：根结点是堆有序的二叉树中的最大结点
 * 
 * 二叉堆表示法：
 * 如果用指针来表示堆有序的二叉树，那么每个元素都需要三个指针来找到它的上下结点（父节点和两个子节点各需要一个）
 * 
 * 如果我们使用完全二叉树，
 * 可以先定下根结点，然后逐层由上向下，从左到右，
 * 在每个结点的下方连接两个更小的结点，直至将N个结点全部连接完毕
 * 完全二叉树只用数组而不需要指针就可以表示。
 * 
 * 二叉树的结点按照层级顺序放入数组中，根节点在位置1，它的子节点在位置2和3
 * 子节点的子节点的位置分别在4，5，6，7
 * 
 * 定义：二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组的第一个位置）
 * 
 * 在一个堆中，位置k的结点的父节点的位置为|_k/2_|
 * 则它的两个子结点位置则分别为2k和2k+1。
 * 从a[k]向上一层就令k等于k/2，向下一层则令k等于2k或2k+1
 * 
 * 命题：一棵大小为N的完全二叉树的高度|_lgN_|
 * 
 * 
 */
public class Heap {

}

/***
 * 堆的算法
 * 长度为N+1的私有数组pq[]来表示一个大小为N的堆，堆元素放在pq[1]到pq[N]中
 * 
 * 堆的有序化遇到两种情况：
 * 当某个结点的优先级上升（或者在堆底加入一个新的元素）时，需要由下至上恢复堆的顺序
 * 当某个结点的优先级下降（或者将根节点替换为一个较小的元素）时，需要由上至下恢复堆的顺序
 * 
 * 由下至上的堆有序化（上浮）
 * 如果堆的有序状态因为某个结点变得比它的父节点更大而被打破，要交换它和它的父节点来修复堆
 * 重复使用这个逻辑，直到父节点大于该节点，小于其子节点。
 * 
 * 由上至下的堆有序化（下沉）
 * 如果堆有序状态因为某个节点变得比它的两个子节点或者其中之一更小而被打破。
 * 将它和它的两个子节点中较大的那个交换来恢复堆
 * 重复这个操作，直到它的子节点都比它小，或者到达堆底部。
 * 由位置为k的结点的子节点位于2k和2k+1
 * 
 * 画外：黑社会组织，
 * 上浮是指，新人晋升，直到遇到更强的上司，
 * 下沉是指，领导退休，直到他的能力比其下属都强
 * 
 * 插入元素：
 * 将新元素加入到数组末尾，增加堆的大小并让这个新元素上浮到合适的位置
 * 删除最大元素：
 * 从数组顶端删除最大元素并将数组的最后一个元素放到顶端，
 * 减小堆的大小并让这个元素下沉到合适的位置
 * 
 */

