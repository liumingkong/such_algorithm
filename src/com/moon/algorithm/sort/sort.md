## 排序算法

### 排序算法的规则

排序算法的目的：将所有元素的主键按照某种方式排列（按照大小或者字母顺序）。

* 我们将排序的代码放在类的sort方法中，该类还将包含辅助函数less()(通过Comparable接口实现),exch()。因为大多数情况下，排序代码只会通过两个方法操作数据：less方法对元素比较，exch将元素交换位置。
* 排序算法从存储空间的使用分类：原地排序算法，额外空间排序算法。
* Java的主要类型都实现了Comparable接口。

### Comparable接口

* 用来实现比较功能。
* v.compareTo（w）被调用时返回一个负整数，0，正整数。
* 正整数 v>w,0 v=w, 正整数 v<w

## 排序算法的应用

* 排序算法之所以有用的主要原因，在一个有序的数组中查找一个元素要比在一个无序的数组中查找简单多了。
* 我们实现的排序算法中，排序对象是由实现了Comparable接口的对象组成的数组。对象实现了Comparable接口，在compareTo中定义数据的比较关系。
* 例如说，有的对象排序，可能我们只是依据其中的一个属性进行的排序。
* 使用数据的引用或者指针排序，带来的好处是，不需要移动元素本身，移动的只是引用，降低交换的成本。

### Comprator接口

* 如果一个对象没有继承Comparable接口，它就不具备排序的能力，或者其排序方式并不能满足需求。
* Comparator接口允许我们在一个类中实现多种排序方法，它只有一个compare方法来比较两个对象。
* 一般在应用中，一个元素的多个属性都可能被用来作为排序的键。
* 为了实现灵活性，Comparator接口可以定义多种比较器.
* sort(Key[] a, Comparator<Key> c);
* 传入排序器用来定制比较的方法。
* 通过自定义比较器，实现多种定制化的排序方式。

### 稳定性

* 如果一个排序算法能够保留数组中重复元素的相对位置则被称为是稳定的。
* 这个性质的重要性在于，例如，一个需要处理大量含有地理位置和时间戳的事件的互联网商业应用程序。首先，我们在事件发生时将它们挨个存储到一个数组中，这个数组已经按照时间顺序完成了排序。
* 现在进一步按照地理位置进行切分，如果排序算法是不稳定的，可能排序后的每个城市的交易可能不会再是按照时间顺序。
* 稳定的排序算法：插入排序，归并排序，不稳定的排序算法：选择，希尔，快速，堆排序，也有很多方法可以使不稳定排序变为稳定排序。

### 排序算法的选择

* 大多数情况下，快速排序是最佳选择。
* 如果考虑稳定性，归并排序是不错的选择。
* Java原生采用的是Array.sort()，快速排序（三向切分）
* 找出重复元素：如果数据本身有序，找出重复元素就容易多了。

#### 排名

* 一组排列就是一组N个整数的数组，其中0~N-1的每个数都只出现一次。两个排列之间的Kendall tau距离就是两组数列中顺序不同的数对的数目。
* 例如，0 3 1 6 2 5 4 和 1 0 3 6 4 2 5 之间的Kendall tau距离是4，因为0-1，3-1，2-4，5-4，其他数字的顺序是相同的。
* 某个序列和标准序列的Kendall tau距离实际上就是其中逆序数对的数量。
* 常用于投票，搜索排名，基因图谱。

#### 中位数和顺序统计

* 一个和排序有关又无关的命题是查找一组数中的中位数（中间值，它不大于一半的元素有不小于另一半元素）。它是一种特殊的选择，找到一组数中第k小个元素。
* 可以采用优先队列或者直接排序。


